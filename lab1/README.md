# Лексический анализатор на C++

## Описание

Комплексный лексический анализатор, реализующий несколько методов идентификации лексем для получения максимального количества баллов.

## Использованные методы:

- **Расширяемый конечный автомат** (9 баллов) - для общего распознавания структуры лексем
- **Хеширование** (5 баллов) - для поиска ключевых слов в unordered_set
- **Бинарный поиск** (5 баллов) - для поиска операторов в отсортированном векторе
- **Обработка комментариев** (+2 балла) - поддержка // и /\* \*/ комментариев

**Итого: 21 балл**

## Компиляция и запуск

### Компиляция:

```bash
make
```

### Запуск:

```bash
./lexer input.cpp output.txt
```

### Тестирование:

```bash
make test
```

### Очистка:

```bash
make clean
```

## Структура вывода

Программа создает таблицу лексем в формате:

| Строка | Имя лексемы | Класс      | Значение/Атрибут |
| ------ | ----------- | ---------- | ---------------- |
| 1      | int         | KEYWORD    | -                |
| 1      | x           | IDENTIFIER | id_1_5           |
| 1      | =           | OPERATOR   | -                |
| 1      | 42          | INTEGER    | 42               |

## Поддерживаемые типы лексем:

- **KEYWORD** - ключевые слова (int, float, if, else, etc.)
- **IDENTIFIER** - идентификаторы переменных и функций
- **INTEGER** - целые числа
- **FLOAT** - вещественные числа
- **STRING** - строковые литералы
- **OPERATOR** - операторы (+, -, \*, /, ==, !=, etc.)
- **DELIMITER** - разделители (скобки, запятые, точки с запятой)
- **COMMENT** - комментарии
- **ERROR** - лексические ошибки

## Особенности реализации:

1. **Конечный автомат** с состояниями для каждого типа лексем
2. **Хеш-таблица** на основе unordered_set для быстрого поиска ключевых слов
3. **Бинарный поиск** в отсортированном векторе операторов
4. **Обработка комментариев** с поддержкой вложенности и многострочности
5. **Обработка ошибок** с продолжением анализа после обнаружения ошибки
6. **Детальная таблица лексем** с указанием позиции и атрибутов

## Файлы проекта:

- `lexical_analyzer.cpp` - основной код анализатора
- `Makefile` - файл сборки
- `test_input.cpp` - пример входного файла
- `README.md` - данная инструкция

---

# Подробное описание алгоритмов и структур данных

## 1. Конечный автомат (Finite Automaton)

### Принцип работы

Конечный автомат представляет собой математическую модель вычислений, состоящую из:

- **Множество состояний Q**: `{START, IDENTIFIER_ST, INTEGER_ST, FLOAT_ST, STRING_ST, OPERATOR_ST, ACCEPT, ERROR_ST}`
- **Входной алфавит Σ**: все ASCII символы
- **Функция переходов δ**: определяет следующее состояние на основе текущего состояния и входного символа
- **Начальное состояние q₀**: `START`
- **Множество конечных состояний F**: `{ACCEPT}`

### Диаграмма состояний

```
START
├─ [a-zA-Z_] → IDENTIFIER_ST
├─ [0-9] → INTEGER_ST
├─ ["] → STRING_ST
├─ [operators] → OPERATOR_ST
└─ [delimiters] → ACCEPT

IDENTIFIER_ST
├─ [a-zA-Z0-9_] → IDENTIFIER_ST
└─ [other] → ACCEPT

INTEGER_ST
├─ [0-9] → INTEGER_ST
├─ [.] → FLOAT_ST
└─ [other] → ACCEPT

FLOAT_ST
├─ [0-9] → FLOAT_ST
└─ [other] → ACCEPT
```

### Алгоритм работы

```cpp
State transition(char c) {
    switch (currentState) {
        case START:
            if (isalpha(c) || c == '_') return IDENTIFIER_ST;
            if (isdigit(c)) return INTEGER_ST;
            // ... другие переходы
        case IDENTIFIER_ST:
            if (isalnum(c) || c == '_') return IDENTIFIER_ST;
            return ACCEPT;
        // ... остальные состояния
    }
}
```

### Временная сложность

- **O(n)** где n - длина входной строки
- Каждый символ обрабатывается ровно один раз
- Детерминированный автомат гарантирует линейное время работы

## 2. Хеширование для ключевых слов

### Структура данных

Используется `std::unordered_set<std::string>` - хеш-таблица на основе открытой адресации или метода цепочек.

```cpp
std::unordered_set<std::string> keywords = {
    "int", "float", "double", "char", "bool", "void",
    "if", "else", "while", "for", "do", "switch"
    // ... остальные ключевые слова
};
```

### Принцип работы хеширования

1. **Хеш-функция**: Преобразует строку в числовой индекс

   ```
   hash("int") → 12345 % table_size → bucket_index
   ```

2. **Разрешение коллизий**:
   - Метод цепочек: элементы с одинаковым хешем хранятся в связанном списке
   - Открытая адресация: поиск следующего свободного места

### Алгоритм поиска

```cpp
bool isKeyword(const std::string& word) {
    return keywords.find(word) != keywords.end();
}
```

### Сложность операций

- **Средний случай**: O(1) - константное время поиска
- **Худший случай**: O(n) - все элементы в одной цепочке (редко при хорошей хеш-функции)
- **Память**: O(m) где m - количество ключевых слов

### Преимущества

- Очень быстрый поиск при правильной настройке
- Легко добавлять новые ключевые слова
- Стандартная библиотека C++ оптимизирована

## 3. Бинарный поиск для операторов

### Структура данных

Отсортированный вектор `std::vector<std::string>` с операторами.

```cpp
std::vector<std::string> operators = {
    "!", "!=", "%", "%=", "&", "&&", "&=", "*", "*=", "+", "++", "+=",
    "-", "--", "-=", "/", "/=", "<", "<<", "<<=", "<=", "=", "==",
    ">", ">=", ">>", ">>=", "^", "^=", "|", "|=", "||", "~"
};
std::sort(operators.begin(), operators.end()); // Сортировка
```

### Алгоритм бинарного поиска

```cpp
bool isOperator(const std::string& op) {
    return std::binary_search(operators.begin(), operators.end(), op);
}
```

### Пошаговое выполнение

Для поиска оператора "==" в отсортированном массиве:

```
Итерация 1: left=0, right=31, mid=15, arr[15]="<"  → "==" > "<", left=16
Итерация 2: left=16, right=31, mid=23, arr[23]=">"  → "==" < ">", right=22
Итерация 3: left=16, right=22, mid=19, arr[19]="="  → "==" > "=", left=20
Итерация 4: left=20, right=22, mid=21, arr[21]="==" → Найдено!
```

### Временная сложность

- **Поиск**: O(log n) где n - количество операторов
- **Инициализация**: O(n log n) для сортировки
- **Память**: O(n)

### Сравнение с линейным поиском

| Метод    | Время поиска | Время инициализации | Память |
| -------- | ------------ | ------------------- | ------ |
| Линейный | O(n)         | O(1)                | O(n)   |
| Бинарный | O(log n)     | O(n log n)          | O(n)   |

Для 32 операторов:

- Линейный: до 32 сравнений
- Бинарный: максимум 5 сравнений (log₂ 32 = 5)

## 4. Обработка комментариев

### Алгоритм для однострочных комментариев

```cpp
if (input[position] == '/' && input[position + 1] == '/') {
    size_t start = position;
    while (position < input.length() && input[position] != '\n') {
        position++;
    }
    // Создаем токен комментария
}
```

### Алгоритм для многострочных комментариев

```cpp
if (input[position] == '/' && input[position + 1] == '*') {
    size_t start = position;
    position += 2;
    while (position + 1 < input.length()) {
        if (input[position] == '*' && input[position + 1] == '/') {
            position += 2;
            break; // Конец комментария найден
        }
        if (input[position] == '\n') {
            currentLine++; // Учитываем переводы строк
        }
        position++;
    }
}
```

### Обработка вложенных комментариев (если поддерживается)

```cpp
int nesting_level = 1;
while (position + 1 < input.length() && nesting_level > 0) {
    if (input[position] == '/' && input[position + 1] == '*') {
        nesting_level++;
        position += 2;
    } else if (input[position] == '*' && input[position + 1] == '/') {
        nesting_level--;
        position += 2;
    } else {
        position++;
    }
}
```

## 5. Общая архитектура анализатора

### Основной цикл обработки

```cpp
while (position < input.length()) {
    skipWhitespace();           // O(k) где k - количество пробелов

    if (processComment())       // O(m) где m - длина комментария
        continue;

    char currentChar = input[position];

    if (isalpha(currentChar) || currentChar == '_') {
        // Автомат: O(l) где l - длина идентификатора
        // + хеширование: O(1) средний случай
    } else if (isdigit(currentChar)) {
        // Автомат: O(l) где l - длина числа
    } else if (/* оператор */) {
        // Бинарный поиск: O(log n)
    }
    // ... другие случаи
}
```

### Общая временная сложность

- **Лучший случай**: O(n) где n - размер входного файла
- **Средний случай**: O(n) - линейная обработка с константными операциями поиска
- **Худший случай**: O(n × k) где k - максимальная длина цепочки в хеш-таблице (очень редко)

### Пространственная сложность

- **Входной буфер**: O(n)
- **Таблица токенов**: O(t) где t - количество токенов
- **Ключевые слова**: O(1) - константное количество
- **Операторы**: O(1) - константное количество
- **Общая**: O(n + t) ≈ O(n)

## 6. Оптимизации и улучшения

### Возможные оптимизации

1. **Perfect hashing** для ключевых слов - гарантированный O(1)
2. **Trie (префиксное дерево)** для операторов с общими префиксами
3. **Буферизация ввода** для больших файлов
4. **Параллельная обработка** для независимых участков кода

### Масштабируемость

- Легко добавлять новые типы токенов через расширение автомата
- Простое добавление ключевых слов в хеш-таблицу
- Операторы добавляются в отсортированный массив

### Обработка ошибок

- **Паническое восстановление**: пропуск до ближайшего разделителя
- **Продолжение анализа**: не останавливаемся на первой ошибке
- **Подробная диагностика**: указание строки и позиции ошибки

Данная реализация обеспечивает оптимальный баланс между производительностью, простотой реализации и возможностями расширения, что делает её подходящей как для учебных целей, так и для практического использования.
