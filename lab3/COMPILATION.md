╔════════════════════════════════════════════════════════════════════════╗
║         ЛАБОРАТОРНАЯ РАБОТА 3: ГЕНЕРАТОР КОДА                          ║
║                 Three-Address Code Compiler (TAC)                       ║
╚════════════════════════════════════════════════════════════════════════╝

📋 СОДЕРЖАНИЕ ПРОЕКТА
═════════════════════════════════════════════════════════════════════════

✓ ОСНОВНЫЕ КОМПОНЕНТЫ (6 этапов компиляции):
  1. Лексический анализ (Lexer)          - lexer.h
  2. Синтаксический анализ (Parser)      - parser.h  
  3. Семантический анализ (Semantic)     - semantic.h
  4. Генерация кода (Code Generator)     - codegen.h
  5. Оптимизация (Optimizer)             - optimizer.h
  6. Интерпретация (Interpreter)         - interpreter.h

✓ ПОДДЕРЖИВАЕМЫЕ КОНСТРУКЦИИ:
  • Переменные: int, bool
  • Выражения: арифметические, логические, сравнения
  • Операторы: if-else, while, for
  • Функции: встроенная функция print()
  • Комментарии: // однострочные, /* многострочные */

✓ ПРОМЕЖУТОЧНОЕ ПРЕДСТАВЛЕНИЕ (IR):
  • Three-Address Code (TAC) - основной формат
  • Поддержка временных переменных (t0, t1, ...)
  • Управление метками (L0, L1, ...) для переходов

✓ ОПТИМИЗАЦИИ:
  • Constant Folding - вычисление констант на этапе компиляции
  • Dead Code Elimination - удаление неиспользуемого кода

✓ ПРОВЕРКА ОШИБОК:
  • Семантический анализ типов
  • Таблица символов
  • Подробные сообщения об ошибках

═════════════════════════════════════════════════════════════════════════
🎯 ОЦЕНИВАНИЕ
═════════════════════════════════════════════════════════════════════════

Базовые баллы:
  ✓ Трехадресный код (TAC)               15 баллов
  
Бонусные баллы:
  ✓ Семантический анализ                 +3 балла
  ✓ Базовая оптимизация (const folding)  +4 балла
  
ИТОГО:                                    22 балла ✓

═════════════════════════════════════════════════════════════════════════
📁 ФАЙЛОВАЯ СТРУКТУРА
═════════════════════════════════════════════════════════════════════════

./
├── Makefile                    # Правила сборки проекта
├── README.md                   # Основная документация
├── USAGE.md                    # Примеры использования
├── ARCHITECTURE.md             # Описание архитектуры
├── COMPILATION.md              # Этот файл
├── quickstart.sh               # Скрипт быстрого старта
│
├── src/                        # Исходные файлы
│   ├── main.cpp                # Главная программа
│   ├── lexer.h                 # Лексический анализатор (730+ строк)
│   ├── parser.h                # Синтаксический анализатор (550+ строк)
│   ├── semantic.h              # Семантический анализ (300+ строк)
│   ├── ir.h                    # Промежуточное представление (250+ строк)
│   ├── codegen.h               # Генератор кода (280+ строк)
│   ├── optimizer.h             # Оптимизатор (180+ строк)
│   └── interpreter.h           # Интерпретатор (240+ строк)
│
├── test/                       # Тестовые примеры
│   ├── example1.txt            # Простые вычисления
│   ├── example2.txt            # Циклы и условия
│   ├── example3.txt            # Оптимизация
│   ├── example4.txt            # Факториал
│   ├── error1.txt              # Ошибка типа
│   └── error2.txt              # Неопределенная переменная
│
├── bin/                        # Скомпилированные файлы
│   └── compiler                # Исполняемый файл
│
└── output/                     # Выходные файлы

═════════════════════════════════════════════════════════════════════════
🚀 БЫСТРЫЙ СТАРТ
═════════════════════════════════════════════════════════════════════════

1. КОМПИЛЯЦИЯ:
   $ make clean
   $ make

2. ЗАПУСК ПРИМЕРА:
   $ ./bin/compiler test/example1.txt

3. ЗАПУСК ВСЕХ ТЕСТОВ:
   $ make test

4. ЗАПУСК БЫСТРОГО СТАРТА:
   $ chmod +x quickstart.sh
   $ ./quickstart.sh

═════════════════════════════════════════════════════════════════════════
📖 ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
═════════════════════════════════════════════════════════════════════════

ПРИМЕР 1: Простые вычисления
─────────────────────────────
$ ./bin/compiler test/example1.txt

Исходный код:
  int a = 10;
  int b = 20;
  int c = a + b;
  print(c);

Выходной TAC:
  0:  t1 = a + b
  1:  c = t1
  2:  print(c)

Результат: 30

ПРИМЕР 2: С оптимизацией
─────────────────────────
$ ./bin/compiler test/example3.txt -noopt    # Без оптимизации
$ ./bin/compiler test/example3.txt           # С оптимизацией

ПРИМЕР 3: Сохранение TAC в файл
────────────────────────────────
$ ./bin/compiler test/example1.txt -o output/result.tac

═════════════════════════════════════════════════════════════════════════
🧪 ТЕСТИРОВАНИЕ
═════════════════════════════════════════════════════════════════════════

Позитивные тесты (должны пройти без ошибок):
  ✓ test/example1.txt  - Арифметика и печать
  ✓ test/example2.txt  - Циклы и условия
  ✓ test/example3.txt  - Оптимизация
  ✓ test/example4.txt  - Факториал (сложная программа)

Негативные тесты (должны обнаружить ошибки):
  ✓ test/error1.txt    - Несовместимость типов
  ✓ test/error2.txt    - Неопределенная переменная

═════════════════════════════════════════════════════════════════════════
🔧 ПАРАМЕТРЫ КОМПИЛЯТОРА
═════════════════════════════════════════════════════════════════════════

Использование:
  ./bin/compiler <source_file> [options]

Опции:
  -tokens          Вывести список токенов
  -ast             Вывести Abstract Syntax Tree
  -noopt           Отключить оптимизацию
  -o <file>        Сохранить TAC в файл

Примеры:
  ./bin/compiler test/example1.txt -tokens
  ./bin/compiler test/example2.txt -noopt
  ./bin/compiler test/example1.txt -o output/tac.ir

═════════════════════════════════════════════════════════════════════════
📊 СТАТИСТИКА КОДА
═════════════════════════════════════════════════════════════════════════

Языки программирования:
  • C++ (C++17)      - 2500+ строк
  • Makefile         - 50 строк
  • Bash             - 50 строк

Компоненты:
  • Headers (.h)     - 2400+ строк
  • Main program     - 150 строк
  • Test files       - 6 примеров
  • Документация     - 800+ строк

═════════════════════════════════════════════════════════════════════════
💡 ОСОБЕННОСТИ РЕАЛИЗАЦИИ
═════════════════════════════════════════════════════════════════════════

✨ Лексический анализ:
  • Автоматическое распознавание ключевых слов
  • Поддержка однострочных и многострочных комментариев
  • Точный подсчет позиций (line, column) для каждого токена

✨ Синтаксический анализ:
  • Метод рекурсивного спуска (recursive descent)
  • Правильная обработка приоритета операторов
  • Полная поддержка вложенных выражений

✨ Семантический анализ:
  • Таблица символов для отслеживания переменных
  • Проверка типов на каждой операции
  • Подробные сообщения об ошибках и предупреждениях

✨ Генерация кода:
  • Преобразование выражений в трехадресный код
  • Автоматическое управление временными переменными
  • Генерация меток для циклов и условных переходов

✨ Оптимизация:
  • Constant folding: 2 * 3 → 6 на этапе компиляции
  • Dead code elimination: удаление неиспользуемого кода

✨ Интерпретация:
  • Виртуальная машина для исполнения TAC
  • Полная поддержка всех типов инструкций
  • Обработка ошибок во время выполнения

═════════════════════════════════════════════════════════════════════════
📚 ДОКУМЕНТАЦИЯ
═════════════════════════════════════════════════════════════════════════

  README.md         - Главный файл с описанием и примерами
  USAGE.md          - Подробное описание использования
  ARCHITECTURE.md   - Описание архитектуры компилятора
  COMPILATION.md    - Этот файл (информация о сборке)

═════════════════════════════════════════════════════════════════════════
🎓 ДЛЯ ПРЕЗЕНТАЦИИ
═════════════════════════════════════════════════════════════════════════

Рекомендуется демонстрировать:

1. Структуру проекта и файловую организацию
2. Пример работы на простой программе (example1.txt)
3. Усложненный пример с циклами (example2.txt)
4. Демонстрацию оптимизации (example3.txt)
5. Обработку ошибок (error1.txt, error2.txt)
6. Параметры командной строки (-tokens, -noopt)

Время презентации: ~10-15 минут

═════════════════════════════════════════════════════════════════════════
✅ ТРЕБОВАНИЯ ЛР
═════════════════════════════════════════════════════════════════════════

☑ Интеграция с лексическим и синтаксическим анализаторами
☑ Генерация трехадресного кода (15 баллов)
☑ Обработка базовых конструкций (присваивание, циклы, условия)
☑ Вывод кода в файл и консоль с аннотациями
☑ Семантический анализ (проверка типов, области видимости) +3 балла
☑ Базовая оптимизация (dead code, const folding) +4 балла
☑ Встроенный интерпретатор для проверки исполняемости
☑ Документация и примеры
☑ Полный набор тестов (позитивные и негативные)

═════════════════════════════════════════════════════════════════════════
🏆 ИТОГОВАЯ ОЦЕНКА
═════════════════════════════════════════════════════════════════════════

Ожидаемая оценка: 22 балла из 20+ возможных
  • TAC: 15 баллов ✓
  • Semantic Analysis: +3 балла ✓
  • Optimization: +4 балла ✓

═════════════════════════════════════════════════════════════════════════
📞 СПРАВКА
═════════════════════════════════════════════════════════════════════════

Команды для разработки:

  make              - Компилировать проект
  make debug        - Компилировать с отладкой
  make test         - Запустить все тесты
  make clean        - Очистить артефакты
  make help         - Показать справку

═════════════════════════════════════════════════════════════════════════

Версия: 1.0
Дата: 2025
Курс: Теория языков программирования и методы трансляции
Язык: C++17
Платформа: Linux/Unix

═════════════════════════════════════════════════════════════════════════
